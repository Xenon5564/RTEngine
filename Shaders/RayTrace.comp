#version 450
layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D destImage;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camUp;
uniform vec3 camRight;
uniform float camFOV;

bool RaySphereIntersection(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius, out float t) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir); // should be 1.0 if rayDir is normalized
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return false;
    }

    float sqrtDisc = sqrt(discriminant);
    float t0 = (-b - sqrtDisc) / (2.0 * a);
    float t1 = (-b + sqrtDisc) / (2.0 * a);

    // Return the nearest positive t
    if (t0 > 0.0) {
        t = t0;
        return true;
    } else if (t1 > 0.0) {
        t = t1;
        return true;
    }

    return false; // both intersections are behind the ray
}

vec3 TraceRay(vec3 rayOri, vec3 rayDir)
{
    vec3 finalColor = vec3(0.1, 0.1, 0.1);
    float t;

    vec3 sphereCen = vec3(0.0, 0.0, 0.0);
    vec3 sphereCol = vec3(0.0, 0.5, 1.0);
    float sphereRad = 1.0;

    if(RaySphereIntersection(rayOri, rayDir, sphereCen, sphereRad, t))
    {
        vec3 lightPos = vec3(0.0, 5.0, 0.0);
        float lightStrength = 1.0;

        vec3 hitPoint = rayOri + rayDir * t;
        vec3 normal = normalize(hitPoint - sphereCen);
        vec3 lightDir = normalize(hitPoint - lightPos);

        float lambert = max(0.0, dot(normal, lightDir));
        float lightAtten = lightStrength / length(hitPoint - lightPos) * length(hitPoint - lightPos);

        finalColor = sphereCol * lambert * lightAtten;
    }

    return finalColor;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(imgSize);

    float planeDist = 1.0;
    float halfHeight = tan(radians(camFOV * 0.5)) * planeDist;
    float aspect = float(imgSize.x) / float(imgSize.y);
    float halfWidth = halfHeight * aspect;

    vec3 planeCenter = camPos + camForward * planeDist;
    vec3 pointOnPlane = planeCenter
        + (uv.x - 0.5) * 2.0 * halfWidth * camRight
        + (0.5 - uv.y) * 2.0 * halfHeight * camUp;

    vec3 dir = normalize(pointOnPlane - camPos);

    imageStore(destImage, pix, vec4(TraceRay(camPos, dir), 1.0));
}
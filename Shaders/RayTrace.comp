#version 450
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32F, binding = 0) uniform image2D destImage;
layout(rgba32F, binding = 1) uniform image2D accumImage;

uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camUp;
uniform vec3 camRight;
uniform float camFOV;

uniform int globalFrameID; // Frames generated since start
uniform int frameID; //Frames since last camera move

struct Sphere{
    vec3 position;
    float radius;
    vec3 albedo;
    float roughness;
    float metallic;
};

const uint SPHERE_COUNT = 12;
const float PI = 3.14159265358979323846;
const float EPSILON = 0.001;

Sphere spheres[SPHERE_COUNT] = Sphere[](
    Sphere(vec3(-4.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.001, 1),
    Sphere(vec3(-3.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.1, 1),
    Sphere(vec3(-2.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.2, 1),
    Sphere(vec3(-1.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.3, 1),
    Sphere(vec3(0.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.4, 1),
    Sphere(vec3(1.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.5, 1),
    Sphere(vec3(2.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.6, 1),
    Sphere(vec3(3.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.7, 1),
    Sphere(vec3(4.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.8, 1),
    Sphere(vec3(5.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 0.9, 1),
    Sphere(vec3(6.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0), 1.0, 1),
    Sphere(vec3(0.0, -1000.5, 0.0), 1000, vec3(1.0, 1, 1.0), 1, 1)
);

// Randomness
uint hash(uint x) {
    x ^= x >> 17;
    x *= 0xED5AD4BBu;
    x ^= x >> 11;
    x *= 0xAC4C1B51u;
    x ^= x >> 15;
    x *= 0x31848BABu;
    x ^= x >> 14;
    return x;
}
float rand(inout uint seed) {
    seed = hash(seed);
    return float(seed) / float(0xFFFFFFFFu); // Normalize to [0, 1)
}



// GGX helpers
float chiGGX(float v){
    return v > 0 ? 1 : 0;
}

// GGX BRDF helpers
float GGXDistribution(vec3 n, vec3 h, float rough){
    float NoH = dot(n,h);
    float rough2 = rough * rough;
    float NoH2 = NoH * NoH;

    float den = NoH2 * rough2 + (1 - NoH2);
    return (chiGGX(NoH) * rough2) / ( PI * den * den );
}               // Distrubution of microfacets
float GGXSmithG1(float NoV, float roughness) {
    float a = roughness;
    float a2 = a * a;
    float denom = NoV + sqrt(a2 + (1 - a2) * NoV * NoV);
    return NoV / denom;
}                   // Helper of Geometry term
float GGXGeometrySmith(vec3 n, vec3 v, vec3 l, float roughness) {
    float NoV = max(dot(n, v), 0.0);
    float NoL = max(dot(n, l), 0.0);
    return GGXSmithG1(NoV, roughness) * GGXSmithG1(NoL, roughness);
}// Geometry of the microfacets
vec3 FresnelSchlick(float cosT, vec3 F0){
  return F0 + (1-F0) * pow( 1 - cosT, 5);
}                         // Fresnel term 
vec3 sampleGGX(vec3 N, float roughness, inout uint seed) {
    float a = roughness * roughness;

    float u1 = rand(seed);
    float u2 = rand(seed);

    float phi = 2.0 * PI * u1;
    float cosTheta = sqrt((1.0 - u2) / (1.0 + (a * a - 1.0) * u2));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    vec3 H = vec3(
        sinTheta * cos(phi),
        sinTheta * sin(phi),
        cosTheta
    );

    // Align H to the normal's hemisphere
    vec3 up = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);
    vec3 tangentX = normalize(cross(up, N));
    vec3 tangentY = cross(N, tangentX);

    return normalize(
        tangentX * H.x + tangentY * H.y + N * H.z
    );
}       // Importance Sample of microfacets

vec3 sampleHemisphere(vec3 normal, inout uint seed) {
    float u1 = rand(seed);
    float u2 = rand(seed);

    float r = sqrt(u1);
    float theta = 6.28318530718 * u2; // 2π

    float x = r * cos(theta);
    float y = r * sin(theta);
    float z = sqrt(1.0 - u1);

    // Build tangent frame (TBN)
    vec3 tangent = normalize(abs(normal.x) > 0.1 ? cross(normal, vec3(0,1,0)) : cross(normal, vec3(1,0,0)));
    vec3 bitangent = cross(normal, tangent);

    return normalize(x * tangent + y * bitangent + z * normal);
}// Samples cosine-weighted hemisphere oriented around `normal`

vec3 CookTorranceSample(vec3 N, vec3 V, vec3 albedo, float metallic, float roughness, inout vec3 rayDir, inout uint rngSeed) {
    float NoV = max(dot(N, V), 0.0);
    vec3 F0 = mix(vec3(0.04), albedo, metallic);

    // Decide: diffuse or specular sampling
    float probSpecular = mix(0.25, 0.95, metallic); // More metallic = more specular
    if (rand(rngSeed) < probSpecular) {
        // --- SPECULAR BOUNCE ---
        vec3 H = sampleGGX(N, roughness, rngSeed);
        rayDir = reflect(-V, H);  // Reflect around half-vector

        float NoL = max(dot(N, rayDir), 0.0);
        if (NoL <= 0.0) return vec3(0.0); // Below surface → discard

        float NoH = max(dot(N, H), 0.0);
        float VoH = max(dot(V, H), 0.0);

        float D = GGXDistribution(N, H, roughness);
        float G = GGXGeometrySmith(N, V, rayDir, roughness);
        vec3 F = FresnelSchlick(VoH, F0);

        vec3 spec = (D * G * F) / (4.0 * NoV * NoL); // Remove max() for better energy conservation
        float pdf = D * NoH / (4.0 * VoH); // PDF for specular sampling

        return spec / pdf; // Divide by PDF for correct importance sampling
    } else {
        // --- DIFFUSE BOUNCE ---
        rayDir = sampleHemisphere(N, rngSeed);
        float NoL = max(dot(N, rayDir), 0.0);

        vec3 kD = (1.0 - metallic) * (1.0 - clamp(FresnelSchlick(NoV, F0), 0.0, 1.0)); //cant saturate a vec3`
        vec3 diffuse = (albedo / PI) * kD;

        float pdf = NoL / PI; // PDF for cosine-weighted hemisphere sampling
        return diffuse / pdf; // Divide by PDF
    }
} // Final PBR sample

bool RaySphereIntersection(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius, out float t) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir); // should be 1.0 if rayDir is normalized
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return false;
    }

    float sqrtDisc = sqrt(discriminant);
    float t0 = (-b - sqrtDisc) / (2.0 * a);
    float t1 = (-b + sqrtDisc) / (2.0 * a);

    // Return the nearest positive t
    if (t0 > EPSILON) {
        t = t0;
        return true;
    } else if (t1 > EPSILON) {
        t = t1;
        return true;
    }

    return false; // both intersections are behind the ray
}

bool CastRay(vec3 rayOrigin, vec3 rayDir, out Sphere hitSphere, out float t){
    float closestT = 100000000;
    float dis;
    int closestID = -1;

    for(int i = 0; i < SPHERE_COUNT; i++)
    {
        if(RaySphereIntersection(rayOrigin, rayDir, spheres[i].position, spheres[i].radius, dis))
        {
            if(dis < closestT)
            {
                closestT = dis;
                closestID = i;
            }
        }
    }

    if(closestID != -1)
    {
        hitSphere = spheres[closestID];
        t = closestT;
        return true;
    }

    return false;
}

vec3 TraceRay(vec3 camPos, vec3 camToPlaneDir, uint seed)
{
    vec3 rayOri = camPos;
    vec3 rayDir = camToPlaneDir;

    vec3 finalColor = vec3(0, 0, 0);
    vec3 pathThroughput = vec3(1, 1, 1); // Initial throughput

    float t;
    float dummyT;

    Sphere hitSphere;
    Sphere dummySphere;

    for(int b = 0; b < 10; b++)
    {
        if(CastRay(rayOri, rayDir, hitSphere, t))
        {
            vec3 position = hitSphere.position;
            vec3 albedo = hitSphere.albedo;
            float roughness = hitSphere.roughness;
            float metallic = hitSphere.metallic;

            vec3 lightPos = vec3(0.0, 25, 0.0);
            vec3 lightCol = vec3(1.0, 1.0, 1.0); 
            float lightStrength = 500.0;

            vec3 hitPoint = rayOri + rayDir * t;
            vec3 normal = normalize(hitPoint - position);
            vec3 viewDir = -rayDir;

            hitPoint += normal * EPSILON;
            rayOri = hitPoint;

            vec3 brdfValue = CookTorranceSample(normal, viewDir, albedo, metallic, roughness, rayDir, seed);

            // Shadow check
            vec3 lightDir = normalize(lightPos - hitPoint);
            if(!CastRay(hitPoint, lightDir, dummySphere, dummyT))
            {
                float lambert = max(0.0, dot(normal, lightDir));
                float lightDis = length(lightPos - hitPoint);
                float lightAtten = lightStrength / (lightDis * lightDis);

                finalColor += pathThroughput * brdfValue * lightCol * lambert * lightAtten;
            }
            pathThroughput *= brdfValue;
        }
        else
        {
            vec3 skyCol = vec3(0.1, 0.5, 0.5);
            finalColor += pathThroughput * skyCol; // Background color
            break;
        }
    }       
    return finalColor;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(imgSize);

    uint seed = uint(pix.x * 73856093u ^ pix.y * 19349663u ^ uint(globalFrameID * 1000.0)) * uint(frameID + 2);

    float planeDist = 1;
    float halfHeight = tan(radians(camFOV * 0.5)) * planeDist;
    float aspect = float(imgSize.x) / float(imgSize.y);
    float halfWidth = halfHeight * aspect;

    vec3 planeCenter = camPos + camForward * planeDist;
    vec3 pointOnPlane = planeCenter
        + (uv.x - 0.5) * 2.0 * halfWidth * camRight
        + (uv.y - 0.5) * 2.0 * halfHeight * camUp;

    vec3 dir = normalize(pointOnPlane - camPos);

    vec3 prevAverageColor = imageLoad(accumImage, pix).rgb; // Load the accumulated color
    float totalFrames = float(frameID) + 1.0;
    vec3 newAverage = (prevAverageColor * float(frameID) + TraceRay(camPos, dir, seed)) / totalFrames;

    imageStore(accumImage, pix, vec4(newAverage, 1.0)); // Store the new average color
    imageStore(destImage, pix, vec4(newAverage, 1.0));
}
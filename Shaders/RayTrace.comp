#version 450
layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D destImage;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camUp;
uniform vec3 camRight;
uniform float camFOV;

struct Sphere{
    vec3 position;
    float radius;
    vec3 albedo;
};

const uint SPHERE_COUNT = 4;

Sphere spheres[SPHERE_COUNT] = Sphere[](
    Sphere(vec3(-1.0, 1.0, 0.0), 0.5, vec3(1.0, 0.0, 0.0)), // Red
    Sphere(vec3(0.0, 0.0, 0.0), 0.5, vec3(0.0, 1.0, 0.0)), // Green
    Sphere(vec3(1.0, 0.0, 0.0), 0.5, vec3(0.0, 0.0, 1.0)), // Blue
    Sphere(vec3(2.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0))  // White
);

bool RaySphereIntersection(vec3 rayOrigin, vec3 rayDir, vec3 sphereCenter, float radius, out float t) {
    vec3 oc = rayOrigin - sphereCenter;
    float a = dot(rayDir, rayDir); // should be 1.0 if rayDir is normalized
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) {
        return false;
    }

    float sqrtDisc = sqrt(discriminant);
    float t0 = (-b - sqrtDisc) / (2.0 * a);
    float t1 = (-b + sqrtDisc) / (2.0 * a);

    // Return the nearest positive t
    if (t0 > 0.0) {
        t = t0;
        return true;
    } else if (t1 > 0.0) {
        t = t1;
        return true;
    }

    return false; // both intersections are behind the ray
}

bool CastRay(vec3 rayOrigin, vec3 rayDir, out Sphere hitSphere, out float t)
{
    float closestT = 100000000;
    float dis;
    int closestID = -1;

    for(int i = 0; i < SPHERE_COUNT; i++)
    {
        if(RaySphereIntersection(rayOrigin, rayDir, spheres[i].position, spheres[i].radius, dis))
        {
            if(dis < closestT)
            {
                closestT = dis;
                closestID = i;
            }
        }
    }

    if(closestID != -1)
    {
        hitSphere = spheres[closestID];
        t = closestT;
        return true;
    }

    return false;
}

vec3 TraceRay(vec3 rayOri, vec3 rayDir)
{
    vec3 finalColor = vec3(0.1, 0.1, 0.1);
    float t;

    Sphere hitSphere;

    if(CastRay(rayOri, rayDir, hitSphere, t))
    {
        vec3 sphereCen = hitSphere.position;
        vec3 sphereCol = hitSphere.albedo;

        vec3 lightPos = vec3(0.0, 5.0, 0.0);
        float lightStrength = 1.0;

        vec3 hitPoint = rayOri + rayDir * t;
        vec3 normal = normalize(hitPoint - sphereCen);
        hitPoint = hitPoint * normal * 0.001;

        vec3 lightDir = normalize(hitPoint - lightPos);

        float lambert = max(0.0, dot(normal, lightDir));
        float lightAtten = lightStrength / length(hitPoint - lightPos) * length(hitPoint - lightPos);

        finalColor = sphereCol * lambert * lightAtten;
    }

    return finalColor;
}

void main() {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(destImage);
    vec2 uv = (vec2(pix) + vec2(0.5)) / vec2(imgSize);

    float planeDist = 1;
    float halfHeight = tan(radians(camFOV * 0.5)) * planeDist;
    float aspect = float(imgSize.x) / float(imgSize.y);
    float halfWidth = halfHeight * aspect;

    vec3 planeCenter = camPos + camForward * planeDist;
    vec3 pointOnPlane = planeCenter
        + (uv.x - 0.5) * 2.0 * halfWidth * camRight
        + (0.5 - uv.y) * 2.0 * halfHeight * camUp;

    vec3 dir = normalize(pointOnPlane - camPos);

    imageStore(destImage, pix, vec4(TraceRay(camPos, dir), 1.0));
}